// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package db

import (
	"context"
)

const activeStations = `-- name: ActiveStations :many
select station_id, created_at, slug, name, active from stations where active = true
`

func (q *Queries) ActiveStations(ctx context.Context) ([]Station, error) {
	rows, err := q.db.Query(ctx, activeStations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Station
	for rows.Next() {
		var i Station
		if err := rows.Scan(
			&i.StationID,
			&i.CreatedAt,
			&i.Slug,
			&i.Name,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createResult = `-- name: CreateResult :exec
insert into results(result_id, search_id, station_id, extern_id, url, thumbnail, title, uploader, duration, views) values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)
`

type CreateResultParams struct {
	ResultID  string
	SearchID  string
	StationID string
	ExternID  string
	Url       string
	Thumbnail string
	Title     string
	Uploader  string
	Duration  float64
	Views     float64
}

func (q *Queries) CreateResult(ctx context.Context, arg CreateResultParams) error {
	_, err := q.db.Exec(ctx, createResult,
		arg.ResultID,
		arg.SearchID,
		arg.StationID,
		arg.ExternID,
		arg.Url,
		arg.Thumbnail,
		arg.Title,
		arg.Uploader,
		arg.Duration,
		arg.Views,
	)
	return err
}

const createSearch = `-- name: CreateSearch :exec
insert into searches(search_id, station_id, query) values($1,$2,$3)
`

type CreateSearchParams struct {
	SearchID  string
	StationID string
	Query     string
}

func (q *Queries) CreateSearch(ctx context.Context, arg CreateSearchParams) error {
	_, err := q.db.Exec(ctx, createSearch, arg.SearchID, arg.StationID, arg.Query)
	return err
}

const createStation = `-- name: CreateStation :one
insert into stations(station_id, slug, active) values($1, $2, $3) returning station_id, created_at, slug, name, active
`

type CreateStationParams struct {
	StationID string
	Slug      string
	Active    bool
}

func (q *Queries) CreateStation(ctx context.Context, arg CreateStationParams) (Station, error) {
	row := q.db.QueryRow(ctx, createStation, arg.StationID, arg.Slug, arg.Active)
	var i Station
	err := row.Scan(
		&i.StationID,
		&i.CreatedAt,
		&i.Slug,
		&i.Name,
		&i.Active,
	)
	return i, err
}

const createStationMessage = `-- name: CreateStationMessage :one
insert into station_messages(station_message_id, type, station_id, nick, body, parent_id) values($1, $2, $3, $4, $5, $6) returning station_message_id, created_at, type, station_id, parent_id, nick, body
`

type CreateStationMessageParams struct {
	StationMessageID string
	Type             string
	StationID        string
	Nick             string
	Body             string
	ParentID         string
}

func (q *Queries) CreateStationMessage(ctx context.Context, arg CreateStationMessageParams) (StationMessage, error) {
	row := q.db.QueryRow(ctx, createStationMessage,
		arg.StationMessageID,
		arg.Type,
		arg.StationID,
		arg.Nick,
		arg.Body,
		arg.ParentID,
	)
	var i StationMessage
	err := row.Scan(
		&i.StationMessageID,
		&i.CreatedAt,
		&i.Type,
		&i.StationID,
		&i.ParentID,
		&i.Nick,
		&i.Body,
	)
	return i, err
}

const createTrack = `-- name: CreateTrack :one
insert into tracks(track_id, station_id, artist, title, raw_metadata, rotation)
values($1,$2,$3,$4,$5, (coalesce((select min(rotation) from tracks where station_id = $2), 0)))
returning track_id, station_id, created_at, artist, title, raw_metadata, rotation, plays, skips, playing
`

type CreateTrackParams struct {
	TrackID     string
	StationID   string
	Artist      string
	Title       string
	RawMetadata []byte
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) (Track, error) {
	row := q.db.QueryRow(ctx, createTrack,
		arg.TrackID,
		arg.StationID,
		arg.Artist,
		arg.Title,
		arg.RawMetadata,
	)
	var i Track
	err := row.Scan(
		&i.TrackID,
		&i.StationID,
		&i.CreatedAt,
		&i.Artist,
		&i.Title,
		&i.RawMetadata,
		&i.Rotation,
		&i.Plays,
		&i.Skips,
		&i.Playing,
	)
	return i, err
}

const event = `-- name: Event :one
select event_id, event_type, created_at, payload from events where event_id = $1
`

func (q *Queries) Event(ctx context.Context, eventID string) (Event, error) {
	row := q.db.QueryRow(ctx, event, eventID)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.EventType,
		&i.CreatedAt,
		&i.Payload,
	)
	return i, err
}

const incrementTrackPlays = `-- name: IncrementTrackPlays :exec
update tracks set plays = plays + 1 where track_id = $1
`

func (q *Queries) IncrementTrackPlays(ctx context.Context, trackID string) error {
	_, err := q.db.Exec(ctx, incrementTrackPlays, trackID)
	return err
}

const incrementTrackRotation = `-- name: IncrementTrackRotation :exec
update tracks set rotation = rotation + 1 where track_id = $1
`

func (q *Queries) IncrementTrackRotation(ctx context.Context, trackID string) error {
	_, err := q.db.Exec(ctx, incrementTrackRotation, trackID)
	return err
}

const insertEvent = `-- name: InsertEvent :one
insert into events(event_id, event_type, payload) values ($1, $2, $3) returning event_id, event_type, created_at, payload
`

type InsertEventParams struct {
	EventID   string
	EventType string
	Payload   []byte
}

func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, insertEvent, arg.EventID, arg.EventType, arg.Payload)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.EventType,
		&i.CreatedAt,
		&i.Payload,
	)
	return i, err
}

const oldestUnplayedTrack = `-- name: OldestUnplayedTrack :one
select track_id, station_id, created_at, artist, title, raw_metadata, rotation, plays, skips, playing from tracks
where tracks.station_id = $1
and plays = 0
and rotation = (select min(rotation) from tracks where station_id = $1)
order by track_id asc
limit 1
`

func (q *Queries) OldestUnplayedTrack(ctx context.Context, stationID string) (Track, error) {
	row := q.db.QueryRow(ctx, oldestUnplayedTrack, stationID)
	var i Track
	err := row.Scan(
		&i.TrackID,
		&i.StationID,
		&i.CreatedAt,
		&i.Artist,
		&i.Title,
		&i.RawMetadata,
		&i.Rotation,
		&i.Plays,
		&i.Skips,
		&i.Playing,
	)
	return i, err
}

const randomTrack = `-- name: RandomTrack :one
select track_id, station_id, created_at, artist, title, raw_metadata, rotation, plays, skips, playing from tracks
where tracks.station_id = $1
and plays > 0
and rotation = (select min(rotation) from tracks where station_id = $1)
order by random()
limit 1
`

func (q *Queries) RandomTrack(ctx context.Context, stationID string) (Track, error) {
	row := q.db.QueryRow(ctx, randomTrack, stationID)
	var i Track
	err := row.Scan(
		&i.TrackID,
		&i.StationID,
		&i.CreatedAt,
		&i.Artist,
		&i.Title,
		&i.RawMetadata,
		&i.Rotation,
		&i.Plays,
		&i.Skips,
		&i.Playing,
	)
	return i, err
}

const results = `-- name: Results :many
select result_id, search_id, station_id, created_at, extern_id, url, thumbnail, title, uploader, duration, views from results where search_id = $1
`

func (q *Queries) Results(ctx context.Context, searchID string) ([]Result, error) {
	rows, err := q.db.Query(ctx, results, searchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Result
	for rows.Next() {
		var i Result
		if err := rows.Scan(
			&i.ResultID,
			&i.SearchID,
			&i.StationID,
			&i.CreatedAt,
			&i.ExternID,
			&i.Url,
			&i.Thumbnail,
			&i.Title,
			&i.Uploader,
			&i.Duration,
			&i.Views,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const search = `-- name: Search :one
select search_id, station_id, created_at, query, status from searches where search_id = $1
`

func (q *Queries) Search(ctx context.Context, searchID string) (Search, error) {
	row := q.db.QueryRow(ctx, search, searchID)
	var i Search
	err := row.Scan(
		&i.SearchID,
		&i.StationID,
		&i.CreatedAt,
		&i.Query,
		&i.Status,
	)
	return i, err
}

const station = `-- name: Station :one
select station_id, created_at, slug, name, active from stations where slug = $1
`

func (q *Queries) Station(ctx context.Context, slug string) (Station, error) {
	row := q.db.QueryRow(ctx, station, slug)
	var i Station
	err := row.Scan(
		&i.StationID,
		&i.CreatedAt,
		&i.Slug,
		&i.Name,
		&i.Active,
	)
	return i, err
}

const stationMessages = `-- name: StationMessages :many
select station_message_id, created_at, type, station_id, parent_id, nick, body from station_messages where station_id = $1 order by station_message_id desc limit 500
`

func (q *Queries) StationMessages(ctx context.Context, stationID string) ([]StationMessage, error) {
	rows, err := q.db.Query(ctx, stationMessages, stationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StationMessage
	for rows.Next() {
		var i StationMessage
		if err := rows.Scan(
			&i.StationMessageID,
			&i.CreatedAt,
			&i.Type,
			&i.StationID,
			&i.ParentID,
			&i.Nick,
			&i.Body,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const track = `-- name: Track :one
select track_id, station_id, created_at, artist, title, raw_metadata, rotation, plays, skips, playing from tracks where track_id = $1
`

func (q *Queries) Track(ctx context.Context, trackID string) (Track, error) {
	row := q.db.QueryRow(ctx, track, trackID)
	var i Track
	err := row.Scan(
		&i.TrackID,
		&i.StationID,
		&i.CreatedAt,
		&i.Artist,
		&i.Title,
		&i.RawMetadata,
		&i.Rotation,
		&i.Plays,
		&i.Skips,
		&i.Playing,
	)
	return i, err
}
